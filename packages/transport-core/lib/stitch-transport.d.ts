import Transport from './transport';
import Cursor from './cursor';
import Document from './document';
import Result from './result';
import StitchClient from './stitch-client';
import StitchMongoClient from './stitch-mongo-client';
declare class StitchTransport<S extends StitchClient, M extends StitchMongoClient> implements Transport {
    readonly stitchClient: S;
    readonly mongoClient: M;
    aggregate(database: string, collection: string, pipeline?: Document[]): Cursor;
    bulkWrite(): Promise<Result>;
    countDocuments(database: string, collection: string, filter?: Document, options?: Document): Promise<Result>;
    constructor(stitchClient: S, mongoClient: M);
    deleteMany(database: string, collection: string, filter?: Document): Promise<Result>;
    deleteOne(database: string, collection: string, filter?: Document): Promise<Result>;
    distinct(): Cursor;
    estimatedDocumentCount(): Promise<Result>;
    find(database: string, collection: string, filter?: Document, options?: Document): Cursor;
    findOneAndDelete(database: string, collection: string, filter?: Document, options?: Document): Promise<Result>;
    findOneAndReplace(database: string, collection: string, filter?: Document, replacement?: Document, options?: Document): Promise<Result>;
    findOneAndUpdate(database: string, collection: string, filter?: Document, update?: Document, options?: Document): Promise<Result>;
    insertMany(database: string, collection: string, docs?: Document[], options?: Document): Promise<Result>;
    insertOne(database: string, collection: string, doc?: Document, options?: Document): Promise<Result>;
    replaceOne(): Promise<Result>;
    runCommand(): Promise<Result>;
    updateMany(database: string, collection: string, filter?: Document, update?: Document, options?: Document): Promise<Result>;
    updateOne(database: string, collection: string, filter?: Document, update?: Document, options?: Document): Promise<Result>;
    get userId(): string;
    private db;
}
export default StitchTransport;
